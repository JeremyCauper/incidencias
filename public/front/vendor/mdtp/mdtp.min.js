class MaterialDateTimePicker {
    static instances = new Map();
    static LOCALES = {
        es: {
            months: ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
            monthsShort: ['ene.', 'feb.', 'mar.', 'abr.', 'may.', 'jun.', 'jul.', 'ago.', 'sep.', 'oct.', 'nov.', 'dic.'],
            days: ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'],
            daysShort: ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'Sa'],
            daysAbbr: ['Dom.', 'Lun.', 'Mar.', 'Mié.', 'Jue.', 'Vie.', 'Sáb.'],
            cancel: 'Cancelar',
            confirm: 'Aceptar',
            selectDate: 'Seleccionar fecha',
            selectTime: 'Seleccionar hora',
            hour: 'Hora',
            minute: 'Minuto'
        },
        en: {
            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
            monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            daysShort: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
            daysAbbr: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            cancel: 'Cancel',
            confirm: 'OK',
            selectDate: 'Select date',
            selectTime: 'Select time',
            hour: 'Hour',
            minute: 'Minute'
        }
    };

    constructor(options = {}) {
        this.options = {
            inputId: options.inputId,
            mode: options.mode || 'date',
            locale: options.locale || 'es',
            format: options.format || 'DD/MM/YYYY',
            theme: options.theme || 'dark',
            closeOnConfirm: options.closeOnConfirm !== false,
            format24h: options.format24h !== undefined ? options.format24h : false,
            onConfirm: options.onConfirm || (() => { }),
            onCancel: options.onCancel || (() => { })
        };

        // Parse min/max dates with string support (YYYY-MM-DD)
        const parseDateOption = (val, isMax) => {
            if (!val) return null;
            let d;
            if (val instanceof Date) {
                d = new Date(val);
            } else if (typeof val === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(val)) {
                // Parse "YYYY-MM-DD" as local date
                const [y, m, day] = val.split('-').map(Number);
                d = new Date(y, m - 1, day);
            } else {
                d = new Date(val); // Fallback
            }

            if (isNaN(d.getTime())) return null;

            if (isMax) d.setHours(23, 59, 59, 999);
            else d.setHours(0, 0, 0, 0);

            return d;
        };

        this.options.min = parseDateOption(options.min, false);
        this.options.max = parseDateOption(options.max, true);

        if (!this.options.inputId) {
            throw new Error('inputId is required');
        }

        this.input = document.getElementById(this.options.inputId);
        if (!this.input) {
            throw new Error(`Input with id "${this.options.inputId}" not found`);
        }

        this.input.setAttribute('readonly', 'readonly');
        this.input.style.cursor = 'pointer';

        this.locale = MaterialDateTimePicker.LOCALES[this.options.locale] || MaterialDateTimePicker.LOCALES.es;

        const now = new Date();
        this.state = {
            currentDate: new Date(),
            selectedDate: new Date(),
            viewYear: now.getFullYear(),
            viewMonth: now.getMonth(),
            hour: now.getHours(),
            minute: now.getMinutes(),
            period: now.getHours() >= 12 ? 'PM' : 'AM',
            datePickerView: 'date', // 'year' | 'month' | 'date'
            timeView: 'hour', // 'hour' | 'minute'
            clockHandAngle: 0, // Track cumulative rotation
            lastClockValue: 0 // Track last value for continuity
        };

        this.elements = {};
        this.isOpen = false;

        this.init();
        MaterialDateTimePicker.instances.set(this.options.inputId, this);
    }

    init() {
        // Guarda referencias a los handlers para poder removerlos después
        this.eventHandlers = {
            click: () => this.show(),
            focus: () => this.show(),
            keydown: (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    this.show();
                }
            }
        };

        // Ahora usa las referencias almacenadas
        this.input.addEventListener('click', this.eventHandlers.click);
        this.input.addEventListener('focus', this.eventHandlers.focus);
        this.input.addEventListener('keydown', this.eventHandlers.keydown);
    }

    show() {
        if (this.isOpen) return;

        // Reset to date view always when opening
        // Reset to date view always when opening (unless month mode)
        if (this.options.mode === 'month') {
            this.state.datePickerView = 'month-year';
        } else {
            this.state.datePickerView = 'date';
        }
        // Reset to hour view for time picker
        this.state.timeView = 'hour';

        if (this.input.value) {
            // Parse existing value from input
            this.parseInputValue();
        } else {
            // If no value, initialize with today but don't set as selected yet
            const today = new Date();
            this.state.selectedDate = new Date(today);
            this.state.viewYear = today.getFullYear();
            this.state.viewMonth = today.getMonth();
        }

        this.render();
        this.isOpen = true;

        requestAnimationFrame(() => {
            this.elements.overlay.classList.add('active');
            this.elements.picker.classList.add('active');
            this.trapFocus();
        });
    }

    parseInputValue() {
        const value = this.input.value;
        if (value) {
            const dateMatch = value.match(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/);
            if (dateMatch) {
                const [, day, month, year] = dateMatch;
                const parsedDate = new Date(year, month - 1, day);

                // Validate the parsed date
                if (!isNaN(parsedDate.getTime())) {
                    this.state.selectedDate = parsedDate;
                    this.state.viewYear = parsedDate.getFullYear();
                    this.state.viewMonth = parsedDate.getMonth();
                }
            }
        }
    }

    hide() {
        if (!this.isOpen) return;

        // Limpia eventos del reloj
        this.destroyClockInteraction();

        // ← NUEVO: Limpia eventos del picker de mes/año
        if (this.elements.body) {
            const columns = this.elements.body.querySelectorAll('.mdtp-picker-column');
            columns.forEach(column => {
                this.destroyPickerScrollEvents(column);
            });
        }

        this.elements.overlay.classList.remove('active');
        this.elements.picker.classList.remove('active');

        setTimeout(() => {
            if (this.elements.overlay) this.elements.overlay.remove();
            if (this.elements.picker) this.elements.picker.remove();
            this.isOpen = false;
        }, 300);
    }

    render() {
        this.elements.overlay = this.createOverlay();
        this.elements.picker = this.createPicker();

        document.body.appendChild(this.elements.overlay);
        document.body.appendChild(this.elements.picker);
    }

    createOverlay() {
        const overlay = document.createElement('div');
        overlay.className = 'mdtp-overlay';
        overlay.addEventListener('click', () => this.cancel());
        return overlay;
    }

    createPicker() {
        const picker = document.createElement('div');
        picker.className = 'mdtp-picker';
        picker.setAttribute('role', 'dialog');
        picker.setAttribute('aria-modal', 'true');
        picker.setAttribute('data-theme', this.options.theme);

        const container = document.createElement('div');
        container.className = 'mdtp-container';

        container.appendChild(this.createHeader());
        container.appendChild(this.createBody());
        container.appendChild(this.createActions());

        picker.appendChild(container);
        return picker;
    }

    createHeader() {
        const header = document.createElement('div');
        header.className = 'mdtp-header';

        // For time picker, replace header content entirely with time display
        if (this.options.mode === 'time') {
            header.innerHTML = '';
            const timeHeader = this.createTimeHeader();
            header.appendChild(timeHeader);
            return header;
        }

        const label = document.createElement('div');
        label.className = 'mdtp-header-label';

        if (this.options.mode === 'date' || this.options.mode === 'datetime') {
            label.textContent = this.state.viewYear;
            label.style.cursor = 'pointer';
            label.addEventListener('click', () => {
                this.state.datePickerView = 'month-year';
                this.updateBody();
            });
        } else if (this.options.mode === 'month') {
            label.textContent = this.state.viewYear;
        }

        const value = document.createElement('div');
        value.className = 'mdtp-header-value';
        this.elements.headerValue = value;
        this.elements.headerLabel = label;
        this.updateHeaderValue();

        header.appendChild(label);
        header.appendChild(value);
        return header;
    }

    createTimeHeader() {
        const header = document.createElement('div');
        header.className = 'mdtp-time-header';

        const hourSegment = document.createElement('div');
        hourSegment.className = 'mdtp-time-segment' + (this.state.timeView === 'hour' ? ' active' : '');
        const displayHour = this.options.format24h ? this.state.hour : (this.state.hour % 12 || 12);
        hourSegment.textContent = String(displayHour).padStart(2, '0');
        hourSegment.addEventListener('click', () => this.switchTimeView('hour'));
        this.elements.hourSegment = hourSegment;

        const colon = document.createElement('div');
        colon.className = 'mdtp-time-colon';
        colon.textContent = ':';

        const minuteSegment = document.createElement('div');
        minuteSegment.className = 'mdtp-time-segment' + (this.state.timeView === 'minute' ? ' active' : '');
        minuteSegment.textContent = String(this.state.minute).padStart(2, '0');
        minuteSegment.addEventListener('click', () => this.switchTimeView('minute'));
        this.elements.minuteSegment = minuteSegment;

        header.appendChild(hourSegment);
        header.appendChild(colon);
        header.appendChild(minuteSegment);

        if (!this.options.format24h) {
            const periodContainer = document.createElement('div');
            periodContainer.className = 'mdtp-time-period-inline';

            const amBtn = document.createElement('button');
            amBtn.className = 'mdtp-time-period-inline-btn' + (this.state.period === 'AM' ? ' active' : '');
            amBtn.textContent = 'AM';
            amBtn.addEventListener('click', () => this.setPeriod('AM'));
            this.elements.amBtn = amBtn;

            const pmBtn = document.createElement('button');
            pmBtn.className = 'mdtp-time-period-inline-btn' + (this.state.period === 'PM' ? ' active' : '');
            pmBtn.textContent = 'PM';
            pmBtn.addEventListener('click', () => this.setPeriod('PM'));
            this.elements.pmBtn = pmBtn;

            periodContainer.appendChild(amBtn);
            periodContainer.appendChild(pmBtn);
            header.appendChild(periodContainer);
        }

        return header;
    }

    createBody() {
        const body = document.createElement('div');
        body.className = 'mdtp-body';
        this.elements.body = body;

        if (this.options.mode === 'date' || this.options.mode === 'datetime' || this.options.mode === 'month') {
            this.renderDatePickerView();
        } else if (this.options.mode === 'time') {
            body.appendChild(this.createTimePicker());
        }

        return body;
    }

    renderDatePickerView() {
        this.elements.body.innerHTML = '';

        if (this.state.datePickerView === 'month-year') {
            this.elements.body.appendChild(this.createMonthYearPicker());
        } else {
            this.elements.body.appendChild(this.createDatePicker());
        }
    }

    createMonthYearPicker() {
        const container = document.createElement('div');
        container.className = 'mdtp-month-year-container';

        // Close button
        const closeBtn = document.createElement('button');
        closeBtn.className = 'mdtp-close-month-year';
        closeBtn.innerHTML = '➜';
        closeBtn.setAttribute('aria-label', 'Cerrar');
        closeBtn.addEventListener('click', () => {
            // The state is already updated by the pickers, just close
            this.state.datePickerView = 'date';
            this.renderDatePickerView();
            this.updateHeaderValue();
        });

        if (this.options.mode !== 'month') {
            container.appendChild(closeBtn);
        }

        // Year picker
        const yearColumn = this.createPickerColumn('year');
        container.appendChild(yearColumn);

        // Month picker
        const monthColumn = this.createPickerColumn('month');
        container.appendChild(monthColumn);

        // Store references for coordination
        this.pickerLists = {
            year: yearColumn.querySelector('.mdtp-picker-list'),
            month: monthColumn.querySelector('.mdtp-picker-list')
        };

        return container;
    }

    /**
     * Crea una columna de selección (Año o Mes) con scroll virtualizado.
     * Utiliza un pool de elementos DOM reutilizables para optimizar el rendimiento.
     * 
     * @param {string} type - El tipo de selector ('year' o 'month').
     * @return {HTMLElement} - El elemento de la columna creado.
     */
    createPickerColumn(type) {
        const column = document.createElement('div');
        column.className = 'mdtp-picker-column';

        const selector = document.createElement('div');
        selector.className = 'mdtp-picker-selector';
        column.appendChild(selector);

        const list = document.createElement('div');
        list.className = 'mdtp-picker-list';

        const itemHeight = 56;
        const poolSize = 9; // 9 elementos son suficientes para cubrir la vista + buffers

        // Definir valores base (Lista completa de años o meses)
        const baseValues = type === 'year'
            ? Array.from({ length: 3027 }, (_, i) => i + 1)
            : this.locale.months;

        list.dataset.type = type;

        // Crear Pool de elementos DOM (para virtual scroll)
        const pool = [];
        for (let i = 0; i < poolSize; i++) {
            const item = document.createElement('div');
            item.className = 'mdtp-picker-item';
            item.style.top = '0px';
            // Se moverán usando transform para mejorar rendimiento (GPU)
            list.appendChild(item);
            pool.push(item);
        }

        column.appendChild(list);

        // Determinar posición inicial
        const initialValue = type === 'year' ? this.state.viewYear : this.state.viewMonth;
        let initialIndex = type === 'year' ? baseValues.indexOf(initialValue) : initialValue;
        if (initialIndex === -1) initialIndex = 0;

        // Estado interno del scroll
        const state = {
            type,
            baseValues,
            totalItems: baseValues.length,
            itemHeight,
            centerOffset: 112, // (280px altura contenedor - 56px altura item) / 2
            currentIndex: initialIndex,
            offsetY: -initialIndex * itemHeight, // Posición global del scroll (negativa)
            isDragging: false,
            startY: 0,
            startTranslate: 0,
            velocity: 0,
            lastY: 0,
            lastTime: Date.now(),
            pool,
            poolSize
        };

        list.pickerState = state;

        // Renderizado inicial
        this.renderVirtualList(list, state);
        this.initPickerScrollFinite(column, list, state);

        return column;
    }

    /**
     * Mueve el picker a un índice específico de forma programática.
     * 
     * @param {HTMLElement} list - El elemento de la lista.
     * @param {Object} state - El estado del picker.
     * @param {number} targetIndex - El índice al que scrollear.
     */
    scrollPickerToIndex(list, state, targetIndex) {
        // Asegurar que el índice esté dentro de límites válidos
        targetIndex = Math.max(0, Math.min(targetIndex, state.totalItems - 1));

        state.currentIndex = targetIndex;
        const targetOffset = -targetIndex * state.itemHeight;

        // Animar hacia la posición
        this.animateScrollTo(list, state, targetOffset, 300);
    }

    /**
     * Renderiza la lista virtual basándose en la posición actual de scroll (offsetY).
     * Calcula qué elementos deben ser visibles y recicla los nodos del DOM.
     * 
     * @param {HTMLElement} list - El contenedor de la lista.
     * @param {Object} state - El estado del scroll.
     */
    renderVirtualList(list, state) {
        const { offsetY, itemHeight, pool, baseValues, totalItems, centerOffset } = state;

        // Calcular el índice del primer elemento visible
        // offsetY es negativo, por eso lo invertimos.
        // Restamos 4 para usar el buffer superior.
        const firstVisibleIndex = Math.floor(-offsetY / itemHeight) - 4;

        pool.forEach((item, i) => {
            const index = firstVisibleIndex + i; // Índice real en los datos

            if (index >= 0 && index < totalItems) {
                item.style.display = 'flex';
                item.textContent = baseValues[index];
                item.dataset.index = index;
                item.dataset.value = state.type === 'year' ? baseValues[index] : index;

                // Calcular posición visual absoluta
                const visualY = (index * itemHeight) + offsetY + centerOffset;
                item.style.transform = `translateY(${visualY}px)`;

                // Lógica de elemento "activo" (centro de la vista)
                // Si está cerca del centro (112px), es el activo.
                const dist = Math.abs(visualY - centerOffset);
                if (dist < itemHeight / 2) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }

                // Disable invalid months
                item.classList.remove('disabled');
                if (state.type === 'month') {
                    const monthIndex = index;
                    const year = this.state.viewYear;

                    if (this.options.min) {
                        const minDate = this.options.min;
                        if (year < minDate.getFullYear() ||
                            (year === minDate.getFullYear() && monthIndex < minDate.getMonth())) {
                            item.classList.add('disabled');
                        }
                    }
                    if (this.options.max) {
                        const maxDate = this.options.max;
                        if (year > maxDate.getFullYear() ||
                            (year === maxDate.getFullYear() && monthIndex > maxDate.getMonth())) {
                            item.classList.add('disabled');
                        }
                    }
                }
            } else {
                // Ocultar elementos fuera de rango
                item.style.display = 'none';
            }
        });
    }

    /**
     * Inicializa la lógica unificada de scroll (Touch, Mouse, Wheel).
     * Maneja la física, inercia (momentum) y snap (ajuste magnético).
     * 
     * @param {HTMLElement} column - La columna contenedora (escucha eventos).
     * @param {HTMLElement} list - La lista interna.
     * @param {Object} state - El estado del scroll.
     */
    initPickerScrollFinite(column, list, state) {
        const { itemHeight, totalItems } = state;
        let animationFrame = null;
        const scrollSensitivity = 1.0; // 1:1 movimiento dedo-pantalla

        // --- Funciones Auxiliares ---

        // Actualiza el índice seleccionado basado en la posición final
        const updateSelectedValue = () => {
            const rawIndex = Math.round(-state.offsetY / itemHeight);
            state.currentIndex = Math.max(0, Math.min(rawIndex, totalItems - 1));

            this.updatePickerValueFinite(state);
        };

        // Render loop simple para actualizaciones suaves
        const smoothPositionUpdate = () => {
            this.renderVirtualList(list, state);
        }

        // Ajuste magnético (Snap) al elemento más cercano
        const snap = () => {
            const targetIndex = Math.max(0, Math.min(Math.round(-state.offsetY / itemHeight), totalItems - 1));
            const targetOffset = -targetIndex * itemHeight;

            // Si ya estamos ahí, solo actualizar valor
            if (Math.abs(state.offsetY - targetOffset) < 0.5) {
                state.offsetY = targetOffset;
                smoothPositionUpdate();
                updateSelectedValue();
                return;
            }

            // Animar el snap
            this.animateScrollTo(list, state, targetOffset, 400, () => {
                updateSelectedValue();
            });
        };

        // inercia (Momentum) después de soltar el arrastre
        const momentumScroll = () => {
            // Umbral mínimo de velocidad para continuar
            if (Math.abs(state.velocity) > 0.5) {
                state.offsetY += state.velocity;
                state.velocity *= 0.96; // Fricción suave

                // Límites elásticos (Bouncing)
                const minOffset = -(totalItems - 1) * itemHeight;
                const maxOffset = 0;

                // Si se pasa de los bordes, rebota suavemente
                if (state.offsetY > maxOffset) {
                    state.offsetY = maxOffset + (state.offsetY - maxOffset) * 0.2;
                    state.velocity *= 0.5;
                } else if (state.offsetY < minOffset) {
                    state.offsetY = minOffset + (state.offsetY - minOffset) * 0.2;
                    state.velocity *= 0.5;
                }

                smoothPositionUpdate();
                animationFrame = requestAnimationFrame(momentumScroll);
            } else {
                // Fin de la inercia, hacer snap
                snap();
            }
        };

        // --- Manejadores de Eventos ---

        const handleStart = (e) => {
            state.isDragging = true;
            // Soporte unificado Mouse/Touch
            state.startY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
            state.startTranslate = state.offsetY;
            state.velocity = 0;
            state.lastY = state.startY;
            state.lastTime = Date.now();

            // Cancelar animaciones en curso
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            if (list.scrollAnimation) {
                cancelAnimationFrame(list.scrollAnimation);
                list.scrollAnimation = null;
            }
        };

        const handleMove = (e) => {
            if (!state.isDragging) return;

            // Prevenir scroll de la página en móviles
            if (e.cancelable) e.preventDefault();

            const currentY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
            const deltaY = (currentY - state.startY) * scrollSensitivity;
            const currentTime = Date.now();
            const deltaTime = currentTime - state.lastTime;

            state.offsetY = state.startTranslate + deltaY;

            // Cálculo de velocidad para inercia (Velocity tracking)
            if (deltaTime > 0) {
                const v = ((currentY - state.lastY) / deltaTime * 16) * scrollSensitivity;
                // Filtro paso bajo para suavizar picos de velocidad
                state.velocity = state.velocity * 0.2 + v * 0.8;
            }

            state.lastY = currentY;
            state.lastTime = currentTime;

            smoothPositionUpdate();
        };

        const handleEnd = () => {
            if (!state.isDragging) return;
            state.isDragging = false;

            // Decidir entre inercia o snap inmediato
            if (Math.abs(state.velocity) > 1) {
                momentumScroll();
            } else {
                snap();
            }
        };

        const handleWheel = (e) => {
            if (e.cancelable) e.preventDefault();
            if (animationFrame) cancelAnimationFrame(animationFrame);
            if (list.scrollAnimation) cancelAnimationFrame(list.scrollAnimation);

            // Scroll directo con rueda
            const delta = e.deltaY * scrollSensitivity;
            state.offsetY -= delta;

            // Clamp inmediato para la rueda (sin rebote elástico)
            const minOffset = -(totalItems - 1) * itemHeight;
            const maxOffset = 0;
            state.offsetY = Math.max(minOffset, Math.min(maxOffset, state.offsetY));

            smoothPositionUpdate();

            // Debounce para hacer snap al terminar de rodar
            clearTimeout(list.snapTimeout);
            list.snapTimeout = setTimeout(() => {
                snap();
            }, 100);
        };

        // Listeners
        column.addEventListener('mousedown', handleStart);
        column.addEventListener('touchstart', handleStart, { passive: false });

        // Eventos globales para no perder el drag si sales del elemento
        document.addEventListener('mousemove', handleMove, { passive: false });
        document.addEventListener('touchmove', handleMove, { passive: false });
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);

        column.addEventListener('wheel', handleWheel, { passive: false });

        // Almacena función de cleanup
        column._cleanupPickerEvents = () => {
            document.removeEventListener('mousemove', handleMove);
            document.removeEventListener('touchmove', handleMove);
            document.removeEventListener('mouseup', handleEnd);
            document.removeEventListener('touchend', handleEnd);
            column.removeEventListener('wheel', handleWheel);
            column.removeEventListener('mousedown', handleStart);
            column.removeEventListener('touchstart', handleStart);
            if (animationFrame) cancelAnimationFrame(animationFrame);
            clearTimeout(list.snapTimeout);
        };
    }

    /**
     * Anima el scroll hacia una posición objetivo usando una curva Bezier suave.
     * 
     * @param {HTMLElement} list - Elemento lista.
     * @param {Object} state - Estado del scroll.
     * @param {number} targetOffset - Posición final.
     * @param {number} duration - Duración en ms.
     * @param {Function} callback - Función a ejecutar al terminar.
     */
    animateScrollTo(list, state, targetOffset, duration = 400, callback = null) {
        const startOffset = state.offsetY;
        const change = targetOffset - startOffset;
        const startTime = performance.now();

        // Curva "Ease Out Quint" para paradas suaves
        const easeOutQuint = (t) => 1 + (--t) * t * t * t * t;

        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            if (elapsed >= duration) {
                state.offsetY = targetOffset;
                this.renderVirtualList(list, state);
                if (callback) callback();
                list.scrollAnimation = null;
                return;
            }

            const t = elapsed / duration;
            const ease = easeOutQuint(t);

            state.offsetY = startOffset + change * ease;
            this.renderVirtualList(list, state);

            list.scrollAnimation = requestAnimationFrame(animate);
        };

        if (list.scrollAnimation) cancelAnimationFrame(list.scrollAnimation);
        list.scrollAnimation = requestAnimationFrame(animate);
    }

    /**
     * Actualiza el valor seleccionado en el estado global del componente.
     * Sincroniza la visualización (Header, Calendario).
     * 
     * @param {Object} state - Estado local del picker.
     */
    updatePickerValueFinite(state) {
        const { type, baseValues, currentIndex } = state;

        // Validación de seguridad de rango
        const clampedIndex = Math.max(0, Math.min(currentIndex, state.totalItems - 1));
        const value = type === 'year' ? baseValues[clampedIndex] : clampedIndex;

        if (type === 'year') {
            if (this.state.viewYear !== value) {
                this.state.viewYear = value;
                this.updateHeaderLabel();

                // Refresh month list to update disabled states
                if (this.pickerLists && this.pickerLists.month && this.pickerLists.month.pickerState) {
                    this.renderVirtualList(this.pickerLists.month, this.pickerLists.month.pickerState);
                }

                // Check and clamp month validity if needed
                let shouldClamp = false;
                if (this.options.min) {
                    const minD = this.options.min;
                    if (value < minD.getFullYear()) shouldClamp = true; // Shouldn't happen if filtered
                    if (value === minD.getFullYear() && this.state.viewMonth < minD.getMonth()) {
                        this.state.viewMonth = minD.getMonth();
                        shouldClamp = true;
                    }
                }
                if (this.options.max) {
                    const maxD = this.options.max;
                    if (value > maxD.getFullYear()) shouldClamp = true;
                    if (value === maxD.getFullYear() && this.state.viewMonth > maxD.getMonth()) {
                        this.state.viewMonth = maxD.getMonth();
                        shouldClamp = true;
                    }
                }

                // If we clamped month, we might need to sync the month picker scroll position too?
                // For now, syncing selected date is most critical.

                // Importante: Actualizar fecha seleccionada para reflejar cambios en calendario
                this.syncSelectedDate();

                // If clamped, we should ideally animate the month picker to the new valid month.
                if (shouldClamp && this.pickerLists && this.pickerLists.month && this.pickerLists.month.pickerState) {
                    this.scrollPickerToIndex(this.pickerLists.month, this.pickerLists.month.pickerState, this.state.viewMonth);
                }
            }
        } else {
            if (this.state.viewMonth !== value) {
                this.state.viewMonth = value;
                this.syncSelectedDate();
            }
        }
    }

    /**
     * Sincroniza la fecha seleccionada `this.state.selectedDate`
     * con los valores actuales de vista (viewYear, viewMonth).
     * Maneja desbordamiento de días (ej: 31 Feb -> 28 Feb).
     */
    syncSelectedDate() {
        const currentDay = this.state.selectedDate.getDate();
        // Obtener último día del nuevo mes/año seleccionado
        const daysInNewMonth = new Date(this.state.viewYear, this.state.viewMonth + 1, 0).getDate();
        // Ajustar día si excede el máximo del mes
        let newDay = Math.min(currentDay, daysInNewMonth);

        // Ensure new selection respects min/max
        let newDate = new Date(this.state.viewYear, this.state.viewMonth, newDay);

        if (this.options.min) {
            const minTime = new Date(this.options.min);
            minTime.setHours(0, 0, 0, 0);
            if (newDate < minTime) newDate = new Date(minTime);
        }
        if (this.options.max) {
            const maxTime = new Date(this.options.max);
            maxTime.setHours(0, 0, 0, 0);
            if (newDate > maxTime) newDate = new Date(maxTime);
        }

        this.state.selectedDate = newDate;
        this.updateHeaderValue();
    }

    createDatePicker() {
        const container = document.createElement('div');

        const nav = document.createElement('div');
        nav.className = 'mdtp-date-nav';

        const prevBtn = document.createElement('button');
        prevBtn.className = 'mdtp-date-nav-btn';
        prevBtn.innerHTML = '❮';
        prevBtn.setAttribute('aria-label', 'Mes anterior');
        prevBtn.addEventListener('click', () => this.prevMonth());

        const title = document.createElement('div');
        title.className = 'mdtp-date-nav-title';
        title.textContent = `${this.locale.months[this.state.viewMonth]} de ${this.state.viewYear}`;
        title.addEventListener('click', () => {
            this.state.datePickerView = 'month-year';
            this.renderDatePickerView();
        });

        const nextBtn = document.createElement('button');
        nextBtn.className = 'mdtp-date-nav-btn';
        nextBtn.innerHTML = '❯';
        nextBtn.setAttribute('aria-label', 'Mes siguiente');
        nextBtn.addEventListener('click', () => this.nextMonth());

        nav.appendChild(prevBtn);
        nav.appendChild(title);
        nav.appendChild(nextBtn);

        const calendar = document.createElement('div');
        calendar.className = 'mdtp-calendar';

        this.locale.daysShort.forEach(day => {
            const dayEl = document.createElement('div');
            dayEl.className = 'mdtp-calendar-day';
            dayEl.textContent = day;
            calendar.appendChild(dayEl);
        });

        const year = this.state.viewYear;
        const month = this.state.viewMonth;
        const firstDay = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const daysInPrevMonth = new Date(year, month, 0).getDate();

        for (let i = firstDay - 1; i >= 0; i--) {
            const btn = this.createDateButton(daysInPrevMonth - i, month - 1, year, true);
            calendar.appendChild(btn);
        }

        for (let day = 1; day <= daysInMonth; day++) {
            const btn = this.createDateButton(day, month, year, false);
            calendar.appendChild(btn);
        }

        const totalCells = calendar.children.length - 7;
        const remainingCells = 42 - totalCells;

        for (let day = 1; day <= remainingCells; day++) {
            const btn = this.createDateButton(day, month + 1, year, true);
            calendar.appendChild(btn);
        }

        container.appendChild(nav);
        container.appendChild(calendar);
        return container;
    }

    createDateButton(day, month, year, isOtherMonth) {
        const btn = document.createElement('button');
        btn.className = 'mdtp-calendar-date';
        btn.textContent = day;

        if (isOtherMonth) {
            btn.classList.add('other-month');
        }

        const btnDate = new Date(year, month, day);
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        if (btnDate.getTime() === today.getTime()) {
            btn.classList.add('today');
        }

        if (!isOtherMonth &&
            day === this.state.selectedDate.getDate() &&
            month === this.state.selectedDate.getMonth() &&
            year === this.state.selectedDate.getFullYear()) {
            btn.classList.add('selected');
        }

        // Apply Min/Max constraints
        let isDisabled = false;

        // Ensure comparison ignores time
        const currentCheck = new Date(year, month, day);
        currentCheck.setHours(0, 0, 0, 0);

        if (this.options.min) {
            const minTime = new Date(this.options.min);
            minTime.setHours(0, 0, 0, 0);
            if (currentCheck < minTime) isDisabled = true;
        }

        if (this.options.max) {
            const maxTime = new Date(this.options.max);
            maxTime.setHours(0, 0, 0, 0);
            if (currentCheck > maxTime) isDisabled = true;
        }

        if (isDisabled) {
            btn.classList.add('disabled');
        } else {
            btn.addEventListener('click', () => {
                this.selectDate(new Date(year, month, day));
            });
        }

        return btn;
    }

    createTimePicker() {
        const container = document.createElement('div');
        container.className = 'mdtp-time-container';

        // Analog clock container
        const clockContainer = document.createElement('div');
        clockContainer.className = 'mdtp-analog-clock-container';

        const clock = this.createAnalogClock();
        clockContainer.appendChild(clock);

        container.appendChild(clockContainer);

        return container;
    }

    createAnalogClock() {
        const clock = document.createElement('div');
        clock.className = 'mdtp-analog-clock';

        // Center dot
        const center = document.createElement('div');
        center.className = 'mdtp-clock-center';
        clock.appendChild(center);

        // Clock hand
        const hand = document.createElement('div');
        hand.className = 'mdtp-clock-hand';
        this.elements.clockHand = hand;
        clock.appendChild(hand);

        // Numbers container
        this.elements.clockNumbers = clock;
        this.renderClockNumbers();

        // Touch/mouse handlers
        this.initClockInteraction(clock);

        return clock;
    }

    // Add cleanup when switching views
    destroyClockInteraction() {
        if (this.elements.clockNumbers && this.elements.clockNumbers._cleanupEvents) {
            this.elements.clockNumbers._cleanupEvents();
            this.elements.clockNumbers._cleanupEvents = null; // ← Limpia referencia
        }
    }

    // Nuevo método para limpiar eventos del picker de mes/año
    destroyPickerScrollEvents(column) {
        if (column && column._cleanupPickerEvents) {
            column._cleanupPickerEvents();
            column._cleanupPickerEvents = null;
        }
    }

    renderClockNumbers() {
        // Remove existing numbers
        const existingNumbers = this.elements.clockNumbers.querySelectorAll('.mdtp-clock-number');
        existingNumbers.forEach(num => num.remove());

        const isHourView = this.state.timeView === 'hour';
        const radius = 107; // Distance from center
        const centerX = 130;
        const centerY = 129;

        if (isHourView) {
            // Hour numbers (1-12 or 0-23 for 24h format)
            const hours = this.options.format24h ?
                Array.from({
                    length: 24
                }, (_, i) => i) :
                Array.from({
                    length: 12
                }, (_, i) => i === 0 ? 12 : i);

            hours.forEach((hour, index) => {
                const angle = (index * 30 - 90) * (Math.PI / 180); // Start from top
                const isInner = this.options.format24h && hour >= 1 && hour <= 12;
                const r = isInner ? radius * 0.625 : radius;

                const x = centerX + r * Math.cos(angle);
                const y = centerY + r * Math.sin(angle);

                const number = document.createElement('div');
                number.className = 'mdtp-clock-number' + (isInner ? ' inner' : '');
                number.textContent = hour === 0 ? '00' : hour;
                number.style.left = `${x}px`;
                number.style.top = `${y}px`;
                number.style.transform = 'translate(-50%, -50%)';
                number.dataset.value = hour;

                const currentHour = this.options.format24h ? this.state.hour : (this.state.hour % 12 ||
                    12);
                if (hour === currentHour) {
                    number.classList.add('selected');
                }

                // number.addEventListener('click', () => {
                //    this.selectClockValue(hour, 'hour');
                // });

                this.elements.clockNumbers.appendChild(number);
            });
        } else {
            const clockHand = this.elements.clockHand;
            let hasActiveSelection = false;
            // clockHand.classList.add('minutes');

            // Minute numbers (0, 5, 10, ..., 55)
            for (let minute = 0; minute < 60; minute += 5) {
                const angle = ((minute / 5) * 30 - 90) * (Math.PI / 180);
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);

                const number = document.createElement('div');
                number.className = 'mdtp-clock-number';
                number.textContent = String(minute).padStart(2, '0');
                number.style.left = `${x}px`;
                number.style.top = `${y}px`;
                number.style.transform = 'translate(-50%, -50%)';
                number.dataset.value = minute;

                if (minute === this.state.minute) {
                    number.classList.add('selected');
                    hasActiveSelection = true;
                }

                // number.addEventListener('click', () => {
                //    this.selectClockValue(minute, 'minute');
                // });

                this.elements.clockNumbers.appendChild(number);
            }

            if (!hasActiveSelection) {
                clockHand.classList.add('minutes');
            } else {
                clockHand.classList.remove('minutes');
            }
        }

        this.updateClockHand();
    }

    initClockInteraction(clock) {
        let isDragging = false;
        let lastAngle = null;

        const handleInteraction = (e) => {
            const rect = clock.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;

            const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
            const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

            const x = clientX - rect.left - centerX;
            const y = clientY - rect.top - centerY;

            // Calculate angle from center (0° = 12 o'clock)
            let angle = Math.atan2(y, x) * (180 / Math.PI) + 90;
            if (angle < 0) angle += 360;

            // Handle continuous rotation
            if (lastAngle !== null) {
                let angleDelta = angle - lastAngle;

                // Detect crossing 0°/360° boundary
                if (angleDelta > 180) {
                    angleDelta -= 360;
                } else if (angleDelta < -180) {
                    angleDelta += 360;
                }

                // Update cumulative angle
                this.state.clockHandAngle += angleDelta;
            } else {
                // First interaction - initialize angle
                this.state.clockHandAngle = angle;
            }

            lastAngle = angle;

            // Calculate value and update immediately
            if (this.state.timeView === 'hour') {
                const distance = Math.sqrt(x * x + y * y);
                const isInner = this.options.format24h && distance < 70;

                let normalizedAngle = ((this.state.clockHandAngle % 360) + 360) % 360;
                let hour = Math.round(normalizedAngle / 30);
                if (hour === 0) hour = 12;

                if (this.options.format24h) {
                    if (isInner) {
                        // Inner circle is 1-12
                        // No change needed, angle maps 1-12 correctly
                    } else {
                        // Outer circle is 00, 13-23
                        if (hour === 12) hour = 0;
                        else hour += 12;
                    }
                }

                this.selectClockValue(hour, 'hour', true);
            } else {
                // Minutes - direct following without snapping during drag
                let normalizedAngle = ((this.state.clockHandAngle % 360) + 360) % 360;
                let minute = Math.round(normalizedAngle / 6);
                if (minute === 60) minute = 0;

                this.selectClockValue(minute, 'minute', true);
            }

            // Update hand position immediately
            this.updateClockHand();
        };

        const startDrag = (e) => {
            if (e.type === 'touchstart') {
                // REMOVED: e.preventDefault(); 
                // Letting the event propagate allows 'click' to fire on numbers
                // if the user just taps without dragging.
            }
            isDragging = true;
            lastAngle = null;

            // Initialize cumulative angle from current value
            if (this.state.timeView === 'hour') {
                const hour = this.options.format24h ? this.state.hour : (this.state.hour % 12 || 12);
                this.state.clockHandAngle = hour * 30;
            } else {
                this.state.clockHandAngle = this.state.minute * 6;
            }

            handleInteraction(e);
        };

        const moveDrag = (e) => {
            if (isDragging) {
                if (e.type === 'touchmove') {
                    e.preventDefault();
                }
                handleInteraction(e);
            }
        };

        const endDrag = () => {
            if (isDragging) {
                isDragging = false;
                lastAngle = null;

                // Auto-switch to minutes after selecting hour
                if (this.state.timeView === 'hour') {
                    setTimeout(() => {
                        this.switchTimeView('minute');
                    }, 300);
                }
            }
        };

        // Attach events to clock for start
        clock.addEventListener('mousedown', startDrag);
        clock.addEventListener('touchstart', startDrag, {
            passive: false
        });

        // Attach move and end events to document for global tracking
        document.addEventListener('mousemove', moveDrag);
        document.addEventListener('touchmove', moveDrag, {
            passive: false
        });
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchend', endDrag);

        // Store cleanup function
        clock._cleanupEvents = () => {
            document.removeEventListener('mousemove', moveDrag);
            document.removeEventListener('touchmove', moveDrag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchend', endDrag);
        };
    }

    selectClockValue(value, type, fromDrag = false) {
        if (type === 'hour') {
            if (this.options.format24h) {
                this.state.hour = value;
            } else {
                const hour12 = value === 0 ? 12 : value;
                this.state.hour = this.state.period === 'PM' ?
                    (hour12 === 12 ? 12 : hour12 + 12) :
                    (hour12 === 12 ? 0 : hour12);
            }

            const displayHour = this.options.format24h ? this.state.hour : (this.state.hour % 12 || 12);
            if (this.elements.hourSegment) {
                this.elements.hourSegment.textContent = String(displayHour).padStart(2, '0');
            }
        } else {
            this.state.minute = value;
            if (this.elements.minuteSegment) {
                this.elements.minuteSegment.textContent = String(this.state.minute).padStart(2, '0');
            }
        }

        // OPTIMIZED: Update partial selection instead of full re-render
        this.updateClockSelection();
        this.updateHeaderValue();
    }

    updateClockSelection() {
        if (!this.elements.clockNumbers) return;

        const isHourView = this.state.timeView === 'hour';
        const numbers = this.elements.clockNumbers.querySelectorAll('.mdtp-clock-number');
        const clockHand = this.elements.clockHand;
        let hasActiveSelection = false;

        numbers.forEach(number => {
            const val = parseInt(number.dataset.value, 10);
            let isSelected = false;

            if (isHourView) {
                const currentHour = this.options.format24h ? this.state.hour : (this.state.hour % 12 || 12);
                // Handle 0 vs 12 edge cases
                if (val === 0 && currentHour === 12 && !this.options.format24h) isSelected = false;
                else if (val === 12 && currentHour === 0 && this.options.format24h) isSelected = true;
                else isSelected = val === currentHour;

                // Fix for 12/0 ambiguity in 24h
                if (this.options.format24h) {
                    if (val === 0 && this.state.hour === 0) isSelected = true;
                    if (val === 0 && this.state.hour === 12) isSelected = false;
                    if (val === 12 && this.state.hour === 12) isSelected = true;
                    if (val === 12 && this.state.hour === 0) isSelected = false;
                }
            } else {
                isSelected = val === this.state.minute;
            }

            if (isSelected) {
                number.classList.add('selected');
                hasActiveSelection = true;
            } else {
                number.classList.remove('selected');
            }
        });

        // User Request: If minutes view and no number is selected (e.g. minute 13), add 'minutes' class to hand
        // This likely changes the dot color to white to indicate precise selection
        if (!isHourView) {
            if (!hasActiveSelection) {
                clockHand.classList.add('minutes');
            } else {
                clockHand.classList.remove('minutes');
            }
        } else {
            clockHand.classList.remove('minutes');
        }
    }

    updateClockHand() {
        if (!this.elements.clockHand) return;

        const isHourView = this.state.timeView === 'hour';
        let length;

        if (isHourView) {
            const isInner = this.options.format24h && this.state.hour >= 1 && this.state.hour <= 12;
            length = isInner ? 60 : 100;
        } else {
            length = 100;
        }

        // Use cumulative angle for continuous rotation
        // const angle = this.state.clockHandAngle;
        const angle = isHourView ? this.state.hour * 30 : this.state.minute * 6;

        this.elements.clockHand.style.height = `${length}px`;
        this.elements.clockHand.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
    }

    switchTimeView(view) {
        this.state.timeView = view;

        if (this.elements.hourSegment && this.elements.minuteSegment) {
            this.elements.hourSegment.classList.toggle('active', view === 'hour');
            this.elements.minuteSegment.classList.toggle('active', view === 'minute');
        }

        // Initialize angle for new view
        if (view === 'hour') {
            const hour = this.options.format24h ? this.state.hour : (this.state.hour % 12 || 12);
            this.state.clockHandAngle = hour * 30;
        } else {
            this.state.clockHandAngle = this.state.minute * 6;
        }

        this.renderClockNumbers();
    }

    setPeriod(period) {
        this.state.period = period;

        if (this.elements.amBtn && this.elements.pmBtn) {
            this.elements.amBtn.classList.toggle('active', period === 'AM');
            this.elements.pmBtn.classList.toggle('active', period === 'PM');
        }

        if (!this.options.format24h) {
            const displayHour = this.state.hour % 12 || 12;
            this.state.hour = period === 'PM' ?
                (displayHour === 12 ? 12 : displayHour + 12) :
                (displayHour === 12 ? 0 : displayHour);
        }

        if (this.elements.hourSegment) {
            const displayHour = this.options.format24h ? this.state.hour : (this.state.hour % 12 || 12);
            this.elements.hourSegment.textContent = String(displayHour).padStart(2, '0');
        }

        this.updateHeaderValue();
    }

    createPeriodSelector() {
        const period = document.createElement('div');
        period.className = 'mdtp-time-period';

        const amBtn = document.createElement('button');
        amBtn.className = 'mdtp-time-period-btn' + (this.state.period === 'AM' ? ' active' : '');
        amBtn.textContent = 'AM';
        amBtn.addEventListener('click', () => this.setPeriod('AM'));
        this.elements.amBtn = amBtn;

        const pmBtn = document.createElement('button');
        pmBtn.className = 'mdtp-time-period-btn' + (this.state.period === 'PM' ? ' active' : '');
        pmBtn.textContent = 'PM';
        pmBtn.addEventListener('click', () => this.setPeriod('PM'));
        this.elements.pmBtn = pmBtn;

        period.appendChild(amBtn);
        period.appendChild(pmBtn);

        return period;
    }

    createActions() {
        const actions = document.createElement('div');
        actions.className = 'mdtp-actions';

        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'mdtp-btn mdtp-btn-text';
        cancelBtn.textContent = this.locale.cancel;
        cancelBtn.addEventListener('click', () => this.cancel());

        const confirmBtn = document.createElement('button');
        confirmBtn.className = 'mdtp-btn mdtp-btn-filled';
        confirmBtn.textContent = this.locale.confirm;
        confirmBtn.addEventListener('click', () => this.confirm());

        actions.appendChild(cancelBtn);
        actions.appendChild(confirmBtn);

        return actions;
    }

    updateBody() {
        if (this.elements.body) {
            this.renderDatePickerView();
        }
    }

    updateHeaderLabel() {
        if (this.elements.headerLabel) {
            this.elements.headerLabel.textContent = this.state.viewYear;
        }
    }

    updateHeaderValue() {
        if (!this.elements.headerValue) return;

        if (this.options.mode === 'date' || this.options.mode === 'datetime') {
            const date = this.state.selectedDate;
            const dayName = this.locale.daysAbbr[date.getDay()];
            const day = date.getDate();
            const month = this.locale.monthsShort[date.getMonth()];

            this.elements.headerValue.textContent = `${dayName}, ${day} de ${month}`;
        } else if (this.options.mode === 'month') {
            const date = this.state.selectedDate;
            const month = this.locale.months[date.getMonth()];
            const year = this.state.viewYear;
            this.elements.headerValue.textContent = `${month} ${year}`;
        } else {
            const hour = this.options.format24h ?
                this.state.hour :
                (this.state.hour % 12 || 12);
            const minute = this.state.minute;
            const period = this.options.format24h ? '' : ` ${this.state.period}`;
            this.elements.headerValue.textContent =
                `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}${period}`;
        }
    }

    selectDate(date) {
        // Update the selected date with the exact date clicked
        this.state.selectedDate = new Date(date);
        // Sync view year and month with the selected date
        this.state.viewYear = date.getFullYear();
        this.state.viewMonth = date.getMonth();

        if (this.options.mode === 'datetime') {
            this.switchToTimePicker();
        } else {
            this.renderDatePickerView();
            this.updateHeaderValue();
        }
    }

    switchToTimePicker() {
        this.elements.body.innerHTML = '';
        this.elements.body.appendChild(this.createTimePicker());

        // Update header to time display
        const header = this.elements.picker.querySelector('.mdtp-header');
        header.innerHTML = '';
        const timeHeader = this.createTimeHeader();
        header.appendChild(timeHeader);

        this.updateHeaderValue();
    }

    prevMonth() {
        if (this.state.viewMonth === 0) {
            this.state.viewMonth = 11;
            this.state.viewYear--;
        } else {
            this.state.viewMonth--;
        }

        // Update selected date to maintain consistency
        const currentDay = this.state.selectedDate.getDate();
        const daysInMonth = new Date(this.state.viewYear, this.state.viewMonth + 1, 0).getDate();
        const newDay = Math.min(currentDay, daysInMonth);
        this.state.selectedDate = new Date(this.state.viewYear, this.state.viewMonth, newDay);

        this.updateHeaderLabel();
        this.updateHeaderValue();
        this.renderDatePickerView();
    }

    nextMonth() {
        if (this.state.viewMonth === 11) {
            this.state.viewMonth = 0;
            this.state.viewYear++;
        } else {
            this.state.viewMonth++;
        }

        // Update selected date to maintain consistency
        const currentDay = this.state.selectedDate.getDate();
        const daysInMonth = new Date(this.state.viewYear, this.state.viewMonth + 1, 0).getDate();
        const newDay = Math.min(currentDay, daysInMonth);
        this.state.selectedDate = new Date(this.state.viewYear, this.state.viewMonth, newDay);

        this.updateHeaderLabel();
        this.updateHeaderValue();
        this.renderDatePickerView();
    }

    setPeriod(period) {
        this.state.period = period;

        if (this.elements.amBtn && this.elements.pmBtn) {
            this.elements.amBtn.classList.toggle('active', period === 'AM');
            this.elements.pmBtn.classList.toggle('active', period === 'PM');
        }

        if (!this.options.format24h) {
            const displayHour = this.state.hour % 12 || 12;
            this.state.hour = period === 'PM' ?
                (displayHour === 12 ? 12 : displayHour + 12) :
                (displayHour === 12 ? 0 : displayHour);
        }

        this.updateHeaderValue();
    }

    convert12to24(hour) {
        if (this.state.period === 'PM') {
            return hour === 12 ? 12 : hour + 12;
        }
        return hour === 12 ? 0 : hour;
    }

    confirm() {
        // Validation: Don't confirm if selected date is out of range
        if (this.state.selectedDate) {
            const checkDate = new Date(this.state.selectedDate);
            checkDate.setHours(0, 0, 0, 0);

            if (this.options.min) {
                const minTime = new Date(this.options.min);
                minTime.setHours(0, 0, 0, 0);
                if (checkDate < minTime) return;
            }
            if (this.options.max) {
                const maxTime = new Date(this.options.max);
                maxTime.setHours(0, 0, 0, 0);
                if (checkDate > maxTime) return;
            }
        }

        let result, formattedValue;

        if (this.options.mode === 'date') {
            // Use the currently selected date (not today's date)
            result = new Date(this.state.selectedDate);
            formattedValue = MaterialDateTimePicker.dateTimeFormatter(
                result,
                this.options.format,
                this.options.format24h,
                this.state.period,
                this.locale
            );
        } else if (this.options.mode === 'month') {
            result = new Date(this.state.selectedDate);
            result.setDate(1); // Default to first of month
            formattedValue = MaterialDateTimePicker.dateTimeFormatter(
                result,
                this.options.format,
                this.options.format24h,
                this.state.period,
                this.locale
            );
        } else if (this.options.mode === 'time') {
            result = {
                hour: this.state.hour,
                minute: this.state.minute
            };
            const tempDate = new Date();
            tempDate.setHours(this.state.hour, this.state.minute);
            formattedValue = MaterialDateTimePicker.dateTimeFormatter(
                tempDate,
                this.options.format,
                this.options.format24h,
                this.state.period,
                this.locale
            );
        } else {
            // datetime mode
            const datetime = new Date(this.state.selectedDate);
            datetime.setHours(this.state.hour, this.state.minute, 0, 0);
            result = datetime;
            formattedValue = MaterialDateTimePicker.dateTimeFormatter(
                datetime,
                this.options.format,
                this.options.format24h,
                this.state.period,
                this.locale
            );
        }

        this.input.value = formattedValue;
        this.input.dispatchEvent(new Event('input', { bubbles: true }));
        this.options.onConfirm(result, formattedValue);

        if (this.options.closeOnConfirm) {
            this.hide();
        }
    }

    cancel() {
        this.options.onCancel();
        this.hide();
    }

    trapFocus() {
        const focusableElements = this.elements.picker.querySelectorAll(
            'button, [tabindex]:not([tabindex="-1"])'
        );

        const firstFocusable = focusableElements[0];
        const lastFocusable = focusableElements[focusableElements.length - 1];

        this.elements.picker.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.cancel();
                return;
            }

            if (e.key === 'Tab') {
                if (e.shiftKey) {
                    if (document.activeElement === firstFocusable) {
                        e.preventDefault();
                        lastFocusable.focus();
                    }
                } else {
                    if (document.activeElement === lastFocusable) {
                        e.preventDefault();
                        firstFocusable.focus();
                    }
                }
            }
        });

        firstFocusable.focus();
    }

    destroy() {
        // 1. Cierra el picker si está abierto
        if (this.isOpen) {
            this.hide();
        }

        // 2. CRÍTICO: Remueve todos los event listeners del input
        if (this.input && this.eventHandlers) {
            this.input.removeEventListener('click', this.eventHandlers.click);
            this.input.removeEventListener('focus', this.eventHandlers.focus);
            this.input.removeEventListener('keydown', this.eventHandlers.keydown);
        }

        // 3. Limpia eventos del reloj analógico
        this.destroyClockInteraction();

        // 4. Remueve de la lista de instancias
        MaterialDateTimePicker.instances.delete(this.options.inputId);

        // 5. Limpia todas las referencias para garbage collection
        this.input = null;
        this.elements = {};
        this.eventHandlers = null;
        this.options = null;
        this.state = null;
    }

    val(value) {
        const mode = this.options.mode;
        if (value === undefined) {
            if (!this.input.value) return '';
            this.parseInputValue();

            if (mode === 'time') {
                const hour = this.state.hour;
                const minute = this.state.minute;
                return `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
            }

            const date = this.state.selectedDate;
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}-${m}` + (mode !== 'month' ? `-${d}` : '');
        }

        // SETTER logic
        let parsedDate;

        if (mode === 'time') {
            const [h, m] = String(value).split(':').map(Number);
            if (!isNaN(h) && !isNaN(m)) {
                this.state.hour = h;
                this.state.minute = m;
                this.state.period = h >= 12 ? 'PM' : 'AM';

                // Format for display
                const tempDate = new Date();
                tempDate.setHours(h, m);
                const formatted = MaterialDateTimePicker.dateTimeFormatter(
                    tempDate,
                    this.options.format,
                    this.options.format24h,
                    this.state.period,
                    this.locale
                );
                this.input.value = formatted;
            } else {
                this.input.value = value;
                this.input.dispatchEvent(new Event('input', { bubbles: true }));
            }
        } else {
            // Handle date modes
            if (value instanceof Date) {
                parsedDate = value;
            } else {
                // Expect YYYY-MM-DD
                const parts = String(value).split('-');
                switch (parts.length) {
                    case 3:
                        parsedDate = new Date(parts[0], parts[1] - 1, parts[2]);
                        break;
                    case 2:
                        parsedDate = new Date(parts[0], parts[1] - 1, 1);
                        break;
                    case 1:
                        parsedDate = new Date(parts[0], 0, 1);
                        break;
                }
            }

            if (parsedDate && !isNaN(parsedDate.getTime())) {
                this.state.selectedDate = parsedDate;
                this.state.viewYear = parsedDate.getFullYear();
                this.state.viewMonth = parsedDate.getMonth();

                const formatted = MaterialDateTimePicker.dateTimeFormatter(
                    parsedDate,
                    this.options.format,
                    this.options.format24h,
                    this.state.period,
                    this.locale
                );
                this.input.value = formatted;
                this.input.dispatchEvent(new Event('input', { bubbles: true }));
            } else {
                this.input.value = value;
                this.input.dispatchEvent(new Event('input', { bubbles: true }));
                // Fallback to internal parser if standard parse fails
                this.parseInputValue();
            }
        }

        if (this.isOpen) {
            if (mode === 'month') {
                this.state.datePickerView = 'month-year';
            } else {
                this.state.datePickerView = 'date';
            }
            this.render();
        }
    }

    static dateTimeFormatter(date, pattern, format24h = false, period = 'AM', locale = null) {
        const day = date.getDay();
        const d = date.getDate();
        const m = date.getMonth() + 1;
        const y = date.getFullYear();
        let h = date.getHours();
        const min = date.getMinutes();

        const displayHour = format24h ? h : (h % 12 || 12);

        const tokens = {
            'DD': String(d).padStart(2, '0'),
            'D': String(d),
            'MM': String(m).padStart(2, '0'),
            'M': String(m),
            'YYYY': String(y),
            'YY': String(y).slice(-2),
            'HH': String(displayHour).padStart(2, '0'),
            'H': String(displayHour),
            'mm': String(min).padStart(2, '0'),
            'm': String(min),
            'A': format24h ? '' : period,
            'MMMM': locale ? locale.months[m - 1] : String(m),
            'MMM': locale ? locale.monthsShort[m - 1] : String(m),
            'DDDD': locale ? locale.days[day] : String(day),
            'DDD': locale ? locale.daysAbbr[day] : String(day)
        };

        return pattern.replace(/DDDD|DDD|DD|D|MMMM|MMM|MM|M|YYYY|YY|HH|H|mm|m|A/g, match => tokens[match] || match);
    }
}